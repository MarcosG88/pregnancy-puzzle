<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Surprise! A Puzzle Game</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
</head>

<body>
    <h1>Solve the puzzle to reveal our big news!</h1>

    <!-- <button id="solve-button" onclick="autoSolve()">I give up, show me the news!</button> -->

    <div id="puzzle-container" class="grid-{{ grid_size }}">
        {% for tile in game_state %}
        <div class="tile {% if tile == 'blank' %}blank{% endif %}" onclick="moveTile(this, {{ loop.index0 }})">
            {% if tile != 'blank' %}
            <img src="{{ url_for('static', filename='tiles/' + tile) }}" alt="puzzle tile">
            {% endif %}
        </div>
        {% endfor %}
    </div>
    <button id="solve-button" onclick="autoSolve()">I give up, show me the news!</button>

    <div id="message-container"></div>

    <script>
        // This function forces the puzzle to the solved state
        function autoSolve() {
            // First, make a fetch request to the server to get the solved state
            // This is a simple way to get the final image path and message
            fetch(`/move/0`) // Send a dummy move to check the state
                .then(response => response.json())
                .then(data => {
                    // Call the reveal logic directly
                    revealPuzzle();
                    // Hide the solve button after it's clicked
                    document.getElementById('solve-button').style.display = 'none';
                });
        }

        // New function to handle the reveal logic, moved from the moveTile function
        function revealPuzzle() {
            // Update the message
            document.getElementById('message-container').innerHTML = '<h2>Baby G coming in 2026!</h2>';

            const puzzleContainer = document.getElementById('puzzle-container');

            // Clear the puzzle container and its contents
            puzzleContainer.innerHTML = '';

            // Create and append the full-size image
            const fullImage = document.createElement('img');
            fullImage.src = "{{ url_for('static', filename='surprise_image.jpg') }}";
            fullImage.alt = "Your announcement";
            fullImage.classList.add('full-image-reveal');
            puzzleContainer.appendChild(fullImage);

            // Add a class for potential styling
            puzzleContainer.classList.add('solved');

            // Define the heart shape using a PATH instead of an EMOJI character
            // Note: Paths are single-color only when defined, but force it to be transparent 
            // so the 'colors' array in the main confetti() call can take over.
            const heartPath = confetti.shapeFromPath({
                path: 'M16 28.5l-12.7-12.8c-2.5-2.5-2.5-6.5 0-9.1 2.5-2.5 6.5-2.5 9.1 0l3.6 3.6 3.6-3.6c2.5-2.5 6.5-2.5 9.1 0 2.5 2.5 2.5 6.5 0 9.1l-12.7 12.8z',
                scalar: 1.5 // Adjust the scalar here for base size
            });

            var duration = 15 * 1000;
            var animationEnd = Date.now() + duration;
            // Define colors
            const customColors = ['#990000', '#EE82EE', '#FFFFFF'];
            var defaults = { startVelocity: 30, spread: 360, ticks: 60 };

            function randomInRange(min, max) {
                return Math.random() * (max - min) + min;
            }

            var interval = setInterval(function () {
                var timeLeft = animationEnd - Date.now();

                if (timeLeft <= 0) {
                    return clearInterval(interval);
                }

                var particleCount = 50 * (timeLeft / duration);

                confetti({
                    ...defaults,
                    particleCount,
                    shapes: [heartPath],
                    colors: customColors,
                    scalar: 2, // to adjust size during the call
                    origin: { x: randomInRange(0.1, 0.3), y: Math.random() - 0.2 }
                });

                confetti({
                    ...defaults,
                    particleCount,
                    shapes: [heartPath],
                    colors: customColors,
                    scalar: 2,
                    origin: { x: randomInRange(0.7, 0.9), y: Math.random() - 0.2 }
                });

            }, 250);


        }


        // Update the existing moveTile function to call the new revealPuzzle function
        function moveTile(element, index) {
            fetch(`/move/${index}`)
                .then(response => response.json())
                .then(data => {
                    if (data.is_solved) {
                        revealPuzzle();
                        // Also hide the solve button if they solve it manually
                        document.getElementById('solve-button').style.display = 'none';

                    } else {
                        // This is the logic for a regular move (remains the same)
                        const puzzleContainer = document.getElementById('puzzle-container');
                        puzzleContainer.innerHTML = '';
                        data.game_state.forEach((tile, i) => {
                            const newTile = document.createElement('div');
                            newTile.className = 'tile ' + (tile === 'blank' ? 'blank' : '');
                            newTile.onclick = () => moveTile(newTile, i);
                            if (tile !== 'blank') {
                                const img = document.createElement('img');
                                img.src = "{{ url_for('static', filename='tiles/') }}" + tile;
                                img.alt = 'puzzle tile';
                                newTile.appendChild(img);
                            }
                            puzzleContainer.appendChild(newTile);
                        });
                    }
                });
        }


        function moveTile(element, index) {
            fetch(`/move/${index}`)
                .then(response => response.json())
                .then(data => {
                    if (data.is_solved) {
                        // Update the message and then display the full image
                        document.getElementById('message-container').innerHTML = '<h2>Baby G coming in 2026!</h2>';

                        const puzzleContainer = document.getElementById('puzzle-container');

                        // Clear the puzzle container and its contents
                        puzzleContainer.innerHTML = '';

                        // Create and append the full-size image
                        const fullImage = document.createElement('img');
                        // Use your image file name here
                        fullImage.src = "{{ url_for('static', filename='surprise_image.jpg') }}";
                        fullImage.alt = "Your announcement";
                        fullImage.classList.add('full-image-reveal');
                        puzzleContainer.appendChild(fullImage);

                        // Add a class for potential styling (e.g., to adjust the container)
                        puzzleContainer.classList.add('solved');


                        // Define the heart shape using a PATH instead of an EMOJI character
                        // Note: Paths are single-color only when defined, but force it to be transparent 
                        // so the 'colors' array in the main confetti() call can take over.
                        const heartPath = confetti.shapeFromPath({
                            path: 'M16 28.5l-12.7-12.8c-2.5-2.5-2.5-6.5 0-9.1 2.5-2.5 6.5-2.5 9.1 0l3.6 3.6 3.6-3.6c2.5-2.5 6.5-2.5 9.1 0 2.5 2.5 2.5 6.5 0 9.1l-12.7 12.8z',
                            scalar: 1.5 // Adjust the scalar here for base size
                        });

                        var duration = 15 * 1000;
                        var animationEnd = Date.now() + duration;
                        // Define colors
                        const customColors = ['#990000', '#EE82EE', '#FFFFFF'];
                        var defaults = { startVelocity: 30, spread: 360, ticks: 60 };

                        function randomInRange(min, max) {
                            return Math.random() * (max - min) + min;
                        }

                        var interval = setInterval(function () {
                            var timeLeft = animationEnd - Date.now();

                            if (timeLeft <= 0) {
                                return clearInterval(interval);
                            }

                            var particleCount = 50 * (timeLeft / duration);

                            confetti({
                                ...defaults,
                                particleCount,
                                shapes: [heartPath],
                                colors: customColors,
                                scalar: 2, // to adjust size during the call
                                origin: { x: randomInRange(0.1, 0.3), y: Math.random() - 0.2 }
                            });

                            confetti({
                                ...defaults,
                                particleCount,
                                shapes: [heartPath],
                                colors: customColors,
                                scalar: 2,
                                origin: { x: randomInRange(0.7, 0.9), y: Math.random() - 0.2 }
                            });

                        }, 250);



                    } else {
                        // This is the logic for a regular move
                        const puzzleContainer = document.getElementById('puzzle-container');
                        puzzleContainer.innerHTML = ''; // Clear existing tiles
                        data.game_state.forEach((tile, i) => {
                            const newTile = document.createElement('div');
                            newTile.className = 'tile ' + (tile === 'blank' ? 'blank' : '');
                            newTile.onclick = () => moveTile(newTile, i);
                            if (tile !== 'blank') {
                                const img = document.createElement('img');
                                img.src = "{{ url_for('static', filename='tiles/') }}" + tile;
                                img.alt = 'puzzle tile';
                                newTile.appendChild(img);
                            }
                            puzzleContainer.appendChild(newTile);
                        });
                    }
                });
        }


    </script>

    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.9.4/dist/confetti.browser.min.js"></script>
</body>

</html>